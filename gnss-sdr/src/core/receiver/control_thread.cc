/*!
 * \file control_thread.cc
 * \brief This class implements the receiver control plane
 * \author Carlos Aviles, 2010. carlos.avilesr(at)googlemail.com
 *
 * GNSS Receiver Control Plane: connects the flowgraph, starts running it,
 * and while it does not stop, reads the control messages generated by the blocks,
 * process them, and apply the corresponding actions.
 *
 * -------------------------------------------------------------------------
 *
 * Copyright (C) 2010-2018  (see AUTHORS file for a list of contributors)
 *
 * GNSS-SDR is a software defined Global Navigation
 *          Satellite Systems receiver
 *
 * This file is part of GNSS-SDR.
 *
 * GNSS-SDR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GNSS-SDR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GNSS-SDR. If not, see <https://www.gnu.org/licenses/>.
 *
 * -------------------------------------------------------------------------
 */

#include "control_thread.h"
#include "concurrent_map.h"
#include "concurrent_queue.h"
#include "control_message_factory.h"
#include "file_configuration.h"
#include "galileo_almanac.h"
#include "galileo_ephemeris.h"
#include "galileo_iono.h"
#include "galileo_utc_model.h"
#include "geofunctions.h"
#include "glonass_gnav_ephemeris.h"
#include "glonass_gnav_utc_model.h"
#include "gnss_flowgraph.h"
#include "gnss_sdr_flags.h"
#include "gps_almanac.h"
#include "gps_ephemeris.h"
#include "gps_iono.h"
#include "gps_utc_model.h"
#include "pvt_interface.h"
#include "rtklib_conversions.h"
#include "rtklib_ephemeris.h"
#include "rtklib_rtkcmn.h"
#include <boost/chrono.hpp>
#include <boost/lexical_cast.hpp>
#include <glog/logging.h>
#include <gnuradio/message.h>
#include <algorithm>
#include <cmath>
#include <iostream>
#include <limits>
#include <map>
#include <string>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/types.h>
#include <utility>


using google::LogMessage;


ControlThread::ControlThread()
{
    if (!FLAGS_c.compare("-"))
        {
            configuration_ = std::make_shared<FileConfiguration>(FLAGS_config_file);
        }
    else
        {
            configuration_ = std::make_shared<FileConfiguration>(FLAGS_c);
        }
    delete_configuration_ = false;
    restart_ = false;
    init();
}


ControlThread::ControlThread(std::shared_ptr<ConfigurationInterface> configuration)
{
    configuration_ = configuration;
    delete_configuration_ = false;
    restart_ = false;
    init();
}


void ControlThread::init()
{
    // Instantiates a control queue, a GNSS flowgraph, and a control message factory
    control_queue_ = gr::msg_queue::make(0);
    cmd_interface_.set_msg_queue(control_queue_);  //set also the queue pointer for the telecommand thread
    try
        {
            flowgraph_ = std::make_shared<GNSSFlowgraph>(configuration_, control_queue_);
        }
    catch (const boost::bad_lexical_cast &e)
        {
            std::cout << "Caught bad lexical cast with error " << e.what() << std::endl;
        }
    control_message_factory_ = std::make_shared<ControlMessageFactory>();
    stop_ = false;
    processed_control_messages_ = 0;
    applied_actions_ = 0;
    msqid = -1;
}


ControlThread::~ControlThread()  // NOLINT(modernize-use-equals-default)
{
    if (msqid != -1) msgctl(msqid, IPC_RMID, NULL);
}


void ControlThread::telecommand_listener()
{
    bool telecommand_enabled = configuration_->property("GNSS-SDR.telecommand_enabled", false);
    if (telecommand_enabled)
        {
            int tcp_cmd_port = configuration_->property("GNSS-SDR.telecommand_tcp_port", 3333);
            cmd_interface_.run_cmd_server(tcp_cmd_port);
        }
}


/*
 * Runs the control thread that manages the receiver control plane
 *
 * This is the main loop that reads and process the control messages
 * 1- Connect the GNSS receiver flowgraph
 * 2- Start the GNSS receiver flowgraph
 *    while (flowgraph_->running() && !stop)_{
 * 3- Read control messages and process them }
 */
int ControlThread::run()
{
    // Connect the flowgraph
    try
        {
            flowgraph_->connect();
        }
    catch (const std::exception &e)
        {
            LOG(ERROR) << e.what();
            return 0;
        }
    if (flowgraph_->connected())
        {
            LOG(INFO) << "Flowgraph connected";
        }
    else
        {
            LOG(ERROR) << "Unable to connect flowgraph";
            return 0;
        }
    // Start the flowgraph
    flowgraph_->start();
    if (flowgraph_->running())
        {
            LOG(INFO) << "Flowgraph started";
        }
    else
        {
            LOG(ERROR) << "Unable to start flowgraph";
            return 0;
        }

    // start the keyboard_listener thread
    keyboard_thread_ = boost::thread(&ControlThread::keyboard_listener, this);
    sysv_queue_thread_ = boost::thread(&ControlThread::sysv_queue_listener, this);

    // start the telecommand listener thread
    cmd_interface_.set_pvt(flowgraph_->get_pvt());
    cmd_interface_thread_ = boost::thread(&ControlThread::telecommand_listener, this);

    // Main loop to read and process the control messages
    while (flowgraph_->running() && !stop_)
        {
            //TODO re-enable the blocking read messages functions and fork the process
            read_control_messages();
            if (control_messages_ != 0) process_control_messages();
        }
    std::cout << "Stopping GNSS-SDR, please wait!" << std::endl;
    flowgraph_->stop();
    stop_ = true;
    flowgraph_->disconnect();

// Join keyboard thread
#ifdef OLD_BOOST
    keyboard_thread_.timed_join(boost::posix_time::seconds(1));
    sysv_queue_thread_.timed_join(boost::posix_time::seconds(1));
    cmd_interface_thread_.timed_join(boost::posix_time::seconds(1));
#endif
#ifndef OLD_BOOST
    keyboard_thread_.try_join_until(boost::chrono::steady_clock::now() + boost::chrono::milliseconds(1000));
    sysv_queue_thread_.try_join_until(boost::chrono::steady_clock::now() + boost::chrono::milliseconds(1000));
    cmd_interface_thread_.try_join_until(boost::chrono::steady_clock::now() + boost::chrono::milliseconds(1000));
#endif

    LOG(INFO) << "Flowgraph stopped";

    if (restart_)
        {
            return 42;  // signal the gnss-sdr-harness.sh to restart the receiver program
        }

    return 0;  // normal shutdown
}


void ControlThread::set_control_queue(const gr::msg_queue::sptr &control_queue)
{
    if (flowgraph_->running())
        {
            LOG(WARNING) << "Unable to set control queue while flowgraph is running";
            return;
        }
    control_queue_ = std::move(control_queue);
    cmd_interface_.set_msg_queue(control_queue_);
}



void ControlThread::read_control_messages()
{
    DLOG(INFO) << "Reading control messages from queue";
    gr::message::sptr queue_message = control_queue_->delete_head();
    if (queue_message != 0)
        {
            control_messages_ = control_message_factory_->GetControlMessages(queue_message);
        }
    else
        {
            control_messages_->clear();
        }
}


// Apply the corresponding control actions
void ControlThread::process_control_messages()
{
    for (unsigned int i = 0; i < control_messages_->size(); i++)
        {
            if (stop_) break;
            if (control_messages_->at(i)->who == 200)
                {
                    apply_action(control_messages_->at(i)->what);
                }
            else
                {
                    if (control_messages_->at(i)->who == 300)  // some TC commands require also actions from control_thread
                        {
                            apply_action(control_messages_->at(i)->what);
                        }
                    flowgraph_->apply_action(control_messages_->at(i)->who, control_messages_->at(i)->what);
                }
            processed_control_messages_++;
        }
    control_messages_->clear();
    DLOG(INFO) << "Processed all control messages";
}


void ControlThread::apply_action(unsigned int what)
{
    std::shared_ptr<PvtInterface> pvt_ptr;
    std::vector<std::pair<int, Gnss_Satellite>> visible_satellites;
    switch (what)
        {
        case 0:
            LOG(INFO) << "Received action STOP";
            stop_ = true;
            applied_actions_++;
            break;
        case 1:
            LOG(INFO) << "Received action RESTART";
            stop_ = true;
            restart_ = true;
            applied_actions_++;
            break;
        case 11:
            LOG(INFO) << "Receiver action COLDSTART";
            // delete all ephemeris and almanac information from maps (also the PVT map queue)
            pvt_ptr = flowgraph_->get_pvt();
            pvt_ptr->clear_ephemeris();
            // todo: reorder the satellite queues to the receiver default startup order.
            // This is required to allow repeatability. Otherwise the satellite search order will depend on the last tracked satellites
            break;
        case 12:
            LOG(INFO) << "Receiver action HOTSTART";
            visible_satellites = get_visible_sats(cmd_interface_.get_utc_time(), cmd_interface_.get_LLH());
            // reorder the satellite queue to acquire first those visible satellites
            flowgraph_->priorize_satellites(visible_satellites);
            // start again the satellite acquisitions (done in chained apply_action to flowgraph)
            break;
        case 13:
            LOG(INFO) << "Receiver action WARMSTART";
            // delete all ephemeris and almanac information from maps (also the PVT map queue)
            pvt_ptr = flowgraph_->get_pvt();
            pvt_ptr->clear_ephemeris();
            // load the ephemeris and the almanac from XML files (receiver assistance)
            //read_assistance_from_XML(); TODO read this
            // call here the function that computes the set of visible satellites and its elevation
            // for the date and time specified by the warm start command and the assisted position
            get_visible_sats(cmd_interface_.get_utc_time(), cmd_interface_.get_LLH());
            // reorder the satellite queue to acquire first those visible satellites
            flowgraph_->priorize_satellites(visible_satellites);
            // start again the satellite acquisitions (done in chained apply_action to flowgraph)
            break;
        default:
            LOG(INFO) << "Unrecognized action.";
            break;
        }
}


std::vector<std::pair<int, Gnss_Satellite>> ControlThread::get_visible_sats(time_t rx_utc_time, const arma::vec &LLH)
{
    // 1. Compute rx ECEF position from LLH WGS84
    arma::vec LLH_rad = arma::vec{degtorad(LLH(0)), degtorad(LLH(1)), LLH(2)};
    arma::mat C_tmp = arma::zeros(3, 3);
    arma::vec r_eb_e = arma::zeros(3, 1);
    arma::vec v_eb_e = arma::zeros(3, 1);
    Geo_to_ECEF(LLH_rad, arma::vec{0, 0, 0}, C_tmp, r_eb_e, v_eb_e, C_tmp);

    // 2. Compute rx GPS time from UTC time
    gtime_t utc_gtime;
    utc_gtime.time = rx_utc_time;
    utc_gtime.sec = 0;
    gtime_t gps_gtime = utc2gpst(utc_gtime);

    // 3. loop through all the available ephemeris or almanac and compute satellite positions and elevations
    // store visible satellites in a vector of pairs <int,Gnss_Satellite> to associate an elevation to the each satellite
    std::vector<std::pair<int, Gnss_Satellite>> available_satellites;
    std::vector<unsigned int> visible_gps;
    std::vector<unsigned int> visible_gal;
    std::shared_ptr<PvtInterface> pvt_ptr = flowgraph_->get_pvt();
    struct tm tstruct = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, nullptr};
    char buf[80];
    tstruct = *gmtime(&rx_utc_time);
    strftime(buf, sizeof(buf), "%d/%m/%Y %H:%M:%S ", &tstruct);
    std::string str_time = std::string(buf);
    std::cout << "Get visible satellites at " << str_time
              << "UTC, assuming RX position " << LLH(0) << " [deg], " << LLH(1) << " [deg], " << LLH(2) << " [m]" << std::endl;

    std::map<int, Gps_Ephemeris> gps_eph_map = pvt_ptr->get_gps_ephemeris();
    for (std::map<int, Gps_Ephemeris>::iterator it = gps_eph_map.begin(); it != gps_eph_map.end(); ++it)
        {
            eph_t rtklib_eph = eph_to_rtklib(it->second);
            double r_sat[3];
            double clock_bias_s;
            double sat_pos_variance_m2;
            eph2pos(gps_gtime, &rtklib_eph, &r_sat[0], &clock_bias_s,
                &sat_pos_variance_m2);
            double Az, El, dist_m;
            arma::vec r_sat_eb_e = arma::vec{r_sat[0], r_sat[1], r_sat[2]};
            arma::vec dx = r_sat_eb_e - r_eb_e;
            topocent(&Az, &El, &dist_m, r_eb_e, dx);
            // push sat
            if (El > 0)
                {
                    std::cout << "Using GPS Ephemeris: Sat " << it->second.i_satellite_PRN << " Az: " << Az << " El: " << El << std::endl;
                    available_satellites.push_back(std::pair<int, Gnss_Satellite>(floor(El),
                        (Gnss_Satellite(std::string("GPS"), it->second.i_satellite_PRN))));
                    visible_gps.push_back(it->second.i_satellite_PRN);
                }
        }

    std::map<int, Galileo_Ephemeris> gal_eph_map = pvt_ptr->get_galileo_ephemeris();
    for (std::map<int, Galileo_Ephemeris>::iterator it = gal_eph_map.begin(); it != gal_eph_map.end(); ++it)
        {
            eph_t rtklib_eph = eph_to_rtklib(it->second);
            double r_sat[3];
            double clock_bias_s;
            double sat_pos_variance_m2;
            eph2pos(gps_gtime, &rtklib_eph, &r_sat[0], &clock_bias_s,
                &sat_pos_variance_m2);
            double Az, El, dist_m;
            arma::vec r_sat_eb_e = arma::vec{r_sat[0], r_sat[1], r_sat[2]};
            arma::vec dx = r_sat_eb_e - r_eb_e;
            topocent(&Az, &El, &dist_m, r_eb_e, dx);
            // push sat
            if (El > 0)
                {
                    std::cout << "Using Galileo Ephemeris: Sat " << it->second.i_satellite_PRN << " Az: " << Az << " El: " << El << std::endl;
                    available_satellites.push_back(std::pair<int, Gnss_Satellite>(floor(El),
                        (Gnss_Satellite(std::string("Galileo"), it->second.i_satellite_PRN))));
                    visible_gal.push_back(it->second.i_satellite_PRN);
                }
        }

    std::map<int, Gps_Almanac> gps_alm_map = pvt_ptr->get_gps_almanac();
    for (std::map<int, Gps_Almanac>::iterator it = gps_alm_map.begin(); it != gps_alm_map.end(); ++it)
        {
            alm_t rtklib_alm = alm_to_rtklib(it->second);
            double r_sat[3];
            double clock_bias_s;
            gtime_t aux_gtime;
            aux_gtime.time = fmod(utc2gpst(gps_gtime).time + 345600, 604800);
            alm2pos(aux_gtime, &rtklib_alm, &r_sat[0], &clock_bias_s);
            double Az, El, dist_m;
            arma::vec r_sat_eb_e = arma::vec{r_sat[0], r_sat[1], r_sat[2]};
            arma::vec dx = r_sat_eb_e - r_eb_e;
            topocent(&Az, &El, &dist_m, r_eb_e, dx);
            // push sat
            std::vector<unsigned int>::iterator it2;
            if (El > 0)
                {
                    it2 = std::find(visible_gps.begin(), visible_gps.end(), it->second.i_satellite_PRN);
                    if (it2 == visible_gps.end())
                        {
                            std::cout << "Using GPS Almanac:  Sat " << it->second.i_satellite_PRN << " Az: " << Az << " El: " << El << std::endl;
                            available_satellites.push_back(std::pair<int, Gnss_Satellite>(floor(El),
                                (Gnss_Satellite(std::string("GPS"), it->second.i_satellite_PRN))));
                        }
                }
        }

    std::map<int, Galileo_Almanac> gal_alm_map = pvt_ptr->get_galileo_almanac();
    for (std::map<int, Galileo_Almanac>::iterator it = gal_alm_map.begin(); it != gal_alm_map.end(); ++it)
        {
            alm_t rtklib_alm = alm_to_rtklib(it->second);
            double r_sat[3];
            double clock_bias_s;
            gtime_t gal_gtime;
            gal_gtime.time = fmod(utc2gpst(gps_gtime).time + 345600, 604800);
            alm2pos(gal_gtime, &rtklib_alm, &r_sat[0], &clock_bias_s);
            double Az, El, dist_m;
            arma::vec r_sat_eb_e = arma::vec{r_sat[0], r_sat[1], r_sat[2]};
            arma::vec dx = r_sat_eb_e - r_eb_e;
            topocent(&Az, &El, &dist_m, r_eb_e, dx);
            // push sat
            std::vector<unsigned int>::iterator it2;
            if (El > 0)
                {
                    it2 = std::find(visible_gal.begin(), visible_gal.end(), it->second.i_satellite_PRN);
                    if (it2 == visible_gal.end())
                        {
                            std::cout << "Using Galileo Almanac:  Sat " << it->second.i_satellite_PRN << " Az: " << Az << " El: " << El << std::endl;
                            available_satellites.push_back(std::pair<int, Gnss_Satellite>(floor(El),
                                (Gnss_Satellite(std::string("Galileo"), it->second.i_satellite_PRN))));
                        }
                }
        }

    // sort the visible satellites in ascending order of elevation
    std::sort(available_satellites.begin(), available_satellites.end(), [](const std::pair<int, Gnss_Satellite> &a, const std::pair<int, Gnss_Satellite> &b) {  // use lambda. Cleaner and easier to read
        return a.first < b.first;
    });
    // provide list starting from satellites with higher elevation
    std::reverse(available_satellites.begin(), available_satellites.end());
    return available_satellites;
}



void ControlThread::sysv_queue_listener()
{
    typedef struct
    {
        long mtype;  // required by SysV queue messaging
        double stop_message;
    } stop_msgbuf;

    bool read_queue = true;
    stop_msgbuf msg;
    double received_message = 0.0;
    int msgrcv_size = sizeof(msg.stop_message);

    key_t key = 1102;

    if ((msqid = msgget(key, 0644 | IPC_CREAT)) == -1)
        {
            perror("GNSS-SDR cannot create SysV message queues");
            exit(1);
        }

    while (read_queue && !stop_)
        {
            if (msgrcv(msqid, &msg, msgrcv_size, 1, 0) != -1)
                {
                    received_message = msg.stop_message;
                    if ((std::abs(received_message - (-200.0)) < 10 * std::numeric_limits<double>::epsilon()))
                        {
                            std::cout << "Quit order received, stopping GNSS-SDR !!" << std::endl;
                            std::unique_ptr<ControlMessageFactory> cmf(new ControlMessageFactory());
                            if (control_queue_ != gr::msg_queue::sptr())
                                {
                                    control_queue_->handle(cmf->GetQueueMessage(200, 0));
                                }
                            read_queue = false;
                        }
                }
        }
}


void ControlThread::keyboard_listener()
{
    bool read_keys = true;
    char c = '0';
    while (read_keys && !stop_)
        {
            std::cin.get(c);
            if (c == 'q')
                {
                    std::cout << "Quit keystroke order received, stopping GNSS-SDR !!" << std::endl;
                    std::unique_ptr<ControlMessageFactory> cmf(new ControlMessageFactory());
                    if (control_queue_ != gr::msg_queue::sptr())
                        {
                            control_queue_->handle(cmf->GetQueueMessage(200, 0));
                        }
                    read_keys = false;
                }
            usleep(500000);
        }
}
